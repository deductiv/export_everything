import React, { forwardRef, Suspense, useRef } from 'react'
import { Tab, Tabs, TabList, TabPanel } from 'react-tabs'
import { ThemeProvider, createTheme /* , makeStyles */ } from '@material-ui/core/styles'
import { FormControl, TextField, Select, InputLabel, MenuItem } from '@material-ui/core'
import MaterialTable from '@material-table/core'
// Snackbar notifications
import { useSnackbar } from 'notistack'
// UUID for stanza name generation
import uuid from 'react-native-uuid'
import validator from 'validator'
import moment from 'moment'
import 'moment-timezone'

// Stylesheets
import 'react-tabs/style/react-tabs.css'

// Icons
import Search from '@material-ui/icons/Search'
import FirstPage from '@material-ui/icons/FirstPage'
import LastPage from '@material-ui/icons/LastPage'
import ChevronRight from '@material-ui/icons/ChevronRight'
import ChevronLeft from '@material-ui/icons/ChevronLeft'
import Clear from '@material-ui/icons/Clear'
import ArrowDownward from '@material-ui/icons/ArrowDownward'
import Info from '@material-ui/icons/Info'
import Check from '@material-ui/icons/Check'
import Delete from '@material-ui/icons/Delete'
import Edit from '@material-ui/icons/Edit'
import Add from '@material-ui/icons/Add'
import Remove from '@material-ui/icons/Remove'
import SaveAlt from '@material-ui/icons/SaveAlt'
import FolderIcon from '@material-ui/icons/Folder'
import RefreshIcon from '@material-ui/icons/Refresh'

// Lazy load controls for the file browser UI
const FileBrowserModal = React.lazy(() => import('./FileBrowserModal'))

/* Copyright 2023 Deductiv Inc.
#
# Licensed under the Apache License, Version 2.0 (the 'License')
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an 'AS IS' BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Author: J.R. Murray <jr.murray@deductiv.net>
# Version: 2.3.0 (2023-08-11)
*/

const app = 'export_everything'

const tableIcons = {
  Search: forwardRef((props, ref) => <Search {...props} ref={ref} />),
  FirstPage: forwardRef((props, ref) => <FirstPage {...props} ref={ref} />),
  LastPage: forwardRef((props, ref) => <LastPage {...props} ref={ref} />),
  NextPage: forwardRef((props, ref) => <ChevronRight {...props} ref={ref} />),
  PreviousPage: forwardRef((props, ref) => <ChevronLeft {...props} ref={ref} />),
  Clear: forwardRef((props, ref) => <Clear {...props} ref={ref} />),
  ResetSearch: forwardRef((props, ref) => <Clear {...props} ref={ref} />),
  SortArrow: forwardRef((props, ref) => <ArrowDownward {...props} ref={ref} />),
  Info: forwardRef((props, ref) => <Info {...props} ref={ref} />),
  DetailPanel: forwardRef((props, ref) => <Info {...props} ref={ref} />),
  Check: forwardRef((props, ref) => <Check {...props} ref={ref} />),
  Delete: forwardRef((props, ref) => <Delete {...props} ref={ref} />),
  Edit: forwardRef((props, ref) => <Edit {...props} ref={ref} />),
  Add: forwardRef((props, ref) => <Add {...props} ref={ref} />),
  ThirdStateCheck: forwardRef((props, ref) => <Remove {...props} ref={ref} />),
  Export: forwardRef((props, ref) => <SaveAlt {...props} ref={ref} />),
  Open: forwardRef((props, ref) => <FolderIcon {...props} ref={ref} />),
  Refresh: forwardRef((props, ref) => <RefreshIcon {...props} ref={ref} />)
}

const { enqueueSnackbar } = useSnackbar()

const validators = {
  number: (value) => {
    if (value === undefined || !validator.isFloat(value) || !validator.isInt(value)) {
      return { isValid: false }
    }
    return { isValid: true }
  },
  bool: (value) => {
    if (value === undefined || (value !== true && value !== false)) {
      return { isValid: false }
    }
    return { isValid: true }
  },
  is_true: (value) => {
    return { isValid: booleanize(value) }
  },
  string: (value) => {
    if (value === undefined || validator.isEmpty(value) || !validator.isAscii(value)) {
      return { isValid: false }
    }
    return { isValid: true }
  },
  time: (value) => {
    if (value === undefined || !validator.isDate(value)) {
      return { isValid: false }
    }
    return true
  },
  uuid: (value) => {
    if (value === undefined || !validator.isUUID(value, 4)) {
      return { isValid: false }
    }
    return { isValid: true }
  },
  none: { isValid: true }
}

// Options for notistack - Event notification/alerting library - Success/fail on table operations
const notistackOptions = (variant) => {
  return {
    variant,
    autoHideDuration: 3000
  }
}

const booleanize = (value) => {
  if (value === undefined) {
    return false
  } else if (typeof value === 'string') {
    value = value.toLowerCase()
  }
  switch (value) {
    case true:
    case 'true':
    case 1:
    case '1':
    case 'on':
    case 'yes':
      return true
    default:
      return false
  }
}

/* const cellStyles = {
  wordBreak: 'break-all',
  padding: '0 3px'
} */

const leftTableHeaderStyles = {
  width: '100%',
  textAlign: 'left',
  verticalAlign: 'bottom',
  paddingBottom: '5px',
  whiteSpace: 'pre-wrap'
}

const centerTableHeaderStyles = {
  width: '100%',
  textAlign: 'center',
  verticalAlign: 'bottom',
  paddingBottom: '5px'
}

const centerTableCellStyles = {
  textAlign: 'center',
  paddingRight: '26px'
}

const azureADAuthorities = {
  AZURE_PUBLIC_CLOUD: 'Azure Public Cloud',
  AZURE_CHINA: 'Azure China',
  AZURE_GERMANY: 'Azure Germany',
  AZURE_GOVERNMENT: 'Azure US Government'
}

const azureBlobTypes = {
  blob: 'Blob',
  datalake: 'Data Lake'
}

const tableOptions = {
  grouping: false,
  search: false,
  exportButton: false,
  toolbar: true,
  paging: false,
  draggable: false,
  rowStyle: {
    padding: '0',
    fontSize: '12px',
    wordBreak: 'break-all'
  },
  headerStyle: leftTableHeaderStyles,
  actionsColumnIndex: -1,
  actionsCellStyle: {
    padding: '0',
    justifyContent: 'center'
  }
}

const configDescriptions = {
  ep_hec: 'HTTP Event Collector',
  ep_aws_s3: 'S3-Compatible',
  ep_azure_blob: 'Azure Blob',
  ep_box: 'Box.com',
  ep_sftp: 'SFTP',
  ep_smb: 'SMB'
}

const LoadingOverlayAppConfig = (props) => {
  return (
    <div
      id='loading_overlay'
      style={{
        position: 'fixed',
        left: 0,
        zIndex: 9999,
        width: '100%',
        height: '100%',
        display: 'block',
        background: 'rgba(255, 255, 255, 0.5)'
      }}
    >
      <div style={{
        height: '50%',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center'
      }}
      >
        <span className='spinner_appconfig' />
      </div>
    </div>
  )
}

const LoadingOverlayFileBrowser = (props) => {
  return (
    <div
      id='loading_overlay_file_browser'
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        zIndex: 9999,
        width: '100%',
        height: '100%',
        display: 'block',
        background: 'rgba(0,0,0,0.6)'
      }}
    >
      <div style={{
        height: '100%',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center'
      }}
      >
        <span className='spinner_filebrowser' />
      </div>
    </div>
  )
}
/* async function getAllUrls (urls) {
  try {
    const data = await Promise.all(
      urls.map(
        url =>
          fetch(url).then(
            (response) => response.json()
          )))
    return (data)
  } catch (error) {
    console.log(error)
    throw (error)
  }
} */

// Material-UI v5 migration
const theme = createTheme()

/* const useStyles = makeStyles((theme) => {
  root: {
    // some CSS that accesses the theme
  }
}) */

class App extends React.Component {
  constructor (props) {
    super(props)

    this.state = {
      showFileBrowser: false,
      fileList: [], // begin chonky
      folderChain: [], //
      currentFolder: '', //
      currentConfigContainer: '', //
      currentConfig: '', //
      currentConfigAlias: '', // end chonky,
      loadingConfig: true, // FadeIn control for config load wait
      loadingFileBrowser: false, // FadeIn control for chonky file browsing modal
      ep_general: { },
      // table lists
      ep_hec: [],
      ep_aws: [],
      ep_box: [],
      ep_sftp: [],
      ep_smb: [],
      passwords: [],
      roles: [],
      users: []
    }
    this.isSplunkCloud = false

    this.credentialOwnerSetting = useRef()
    this.credentialReadSetting = useRef()
    this.credentialWriteSetting = useRef()

    // Tabs
    this.EPTabContent = this.EPTabContent.bind(this)

    this.get_config_stanza('ep_general', 'settings').then((d) => {
      console.log('Setting state from constructor')
      this.setState({ ep_general: d })
    })

    // Check to see if we are running Splunk Cloud
    this.get_server_info().then((serverInfo) => {
      this.isSplunkCloud = (serverInfo.instance_type === 'cloud')
      const instanceType = serverInfo.instance_type != null ? serverInfo.instance_type : 'Splunk Enterprise'
      console.log(`Instance type: ${instanceType}`)
    })
    console.log('User: ', JSON.stringify(this.props.splunk.currentUser))
    console.log('Server: ', JSON.stringify(this.props.splunk.serverInfo))

    this.columns = {
      ep_hec: [
        { title: 'Stanza', field: 'stanza', hidden: true },
        // actions = 10%
        {
          title: 'Default',
          field: 'default',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        },
        {
          title: 'Name/Alias',
          field: 'alias',
          width: '20%',
          validate: rowData => validators.string(rowData.alias).isValid
        },
        {
          title: 'Hostname',
          field: 'host',
          width: '25%',
          validate: rowData => validators.string(rowData.host).isValid
        },
        {
          title: 'TCP Port',
          field: 'port',
          width: '10%',
          validate: rowData => (validators.number(rowData.port).isValid || rowData.port == null || rowData.port === '')
        },
        {
          title: 'HEC Token',
          field: 'token',
          width: '20%',
          validate: rowData => validators.uuid(rowData.token).isValid
        },
        {
          title: 'SSL',
          field: 'ssl',
          type: 'boolean',
          width: '5%',
          initialEditValue: 1,
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles,
          // Force SSL to true for Splunk Cloud
          validate: rowData => (this.isSplunkCloud ? validators.is_true(rowData.ssl) : validators.bool(rowData.ssl))
        },
        {
          title: 'Verify SSL',
          field: 'ssl_verify',
          type: 'boolean',
          width: '5%',
          initialEditValue: 1,
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles,
          // Force Verify SSL to true for Splunk Cloud
          validate: rowData => (this.isSplunkCloud ? validators.is_true(rowData.ssl_verify) : validators.bool(rowData.ssl_verify))
        }
      ],
      ep_aws_s3: [
        { title: 'Stanza', field: 'stanza', hidden: true },
        // actions = 10%
        {
          title: 'Default',
          field: 'default',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        },
        {
          title: 'Name/Alias',
          field: 'alias',
          width: '12%',
          validate: rowData => validators.string(rowData.alias)
        },
        {
          title: 'Access Key',
          field: 'credential',
          width: '15%',
          editComponent: props =>
            <FormControl>
              <Select
                id='credential'
                name='credential'
                style={{ width: '150px' }}
                defaultValue={props.value ?? '[EC2 ARN]'}
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem value=''>None</MenuItem>
                <MenuItem value='[EC2 ARN]'>Use EC2 ARN</MenuItem>
                {this.state.passwords.map(credential =>
                  <MenuItem key={credential.stanza} value={credential.stanza}> {credential.stanza}</MenuItem>
                )}
              </Select>
            </FormControl>
        },
        {
          title: 'Region',
          field: 'region',
          width: '10%',
          validate: rowData => validators.string(rowData.region).isValid
        },
        { title: 'Endpoint URL\n(Blank for AWS S3)', field: 'endpoint_url', width: '12%' },
        { title: 'Default Bucket ID', field: 'default_s3_bucket', width: '12%' },
        {
          title: 'Compress Output',
          field: 'compress',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        }
      ],
      ep_azure_blob: [
        { title: 'Stanza', field: 'stanza', hidden: true },
        // actions = 10%
        {
          title: 'Default',
          field: 'default',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        },
        {
          title: 'Name/Alias',
          field: 'alias',
          width: '15%',
          validate: rowData => validators.string(rowData.alias)
        },
        {
          title: 'Storage Account Name',
          field: 'storage_account',
          width: '25%',
          validate: rowData => validators.string(rowData.storage_account)
        },
        {
          title: 'Account Key (Credential)',
          field: 'credential',
          width: '15%',
          editComponent: props =>
            <FormControl>
              <Select
                id='credential'
                name='credential'
                style={{ width: '200px' }}
                defaultValue={props.value === undefined ? '' : props.value}
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem value=''>None</MenuItem>
                {this.state.passwords.map(credential =>
                  <MenuItem key={credential.stanza} value={credential.stanza}> {credential.stanza}</MenuItem>
                )}
              </Select>
            </FormControl>
        },
        {
          title: 'Azure AD',
          field: 'azure_ad',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        },
        {
          title: 'Azure AD Authority',
          field: 'azure_ad_authority',
          width: '15%',
          render: rowData => <span>{azureADAuthorities[rowData.azure_ad_authority]}</span>,
          editComponent: props =>
            <FormControl>
              <Select
                id='azure_ad_authority'
                name='azure_ad_authority'
                disabled={!props.rowData.azure_ad}
                style={{ width: '80px' }}
                defaultValue={props.value === undefined ? '' : props.value}
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem key='' value=''>N/A</MenuItem>
                {Object.entries(azureADAuthorities)
                  .map(([key, value]) => <MenuItem key={key} value={key}> {value}</MenuItem>
                  )}
              </Select>
            </FormControl>
        },
        {
          title: 'Type',
          field: 'type',
          width: '10%',
          render: rowData => <span>{azureBlobTypes[rowData.type]}</span>,
          editComponent: props =>
            <FormControl>
              <Select
                id='type'
                name='type'
                style={{ width: '80px' }}
                defaultValue={props.value === undefined ? '' : props.value}
                onChange={e => { props.onChange(e.target.value) }}
              >
                {Object.entries(azureBlobTypes)
                  .map(([key, value]) => <MenuItem key={key} value={key}> {value}</MenuItem>
                  )}
              </Select>
            </FormControl>
        },
        { title: 'Default Container', field: 'default_container', width: '20%' },
        {
          title: 'Compress Output',
          field: 'compress',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        }
      ],
      ep_box: [
        { title: 'Stanza', field: 'stanza', hidden: true },
        // actions = 10%
        {
          title: 'Default',
          field: 'default',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        },
        {
          title: 'Name/Alias',
          field: 'alias',
          width: '14%',
          validate: rowData => validators.string(rowData.alias).isValid
        },
        {
          title: 'Enterprise ID',
          field: 'enterprise_id',
          width: '10%',
          validate: rowData => validators.string(rowData.enterprise_id).isValid
        },
        {
          title: 'Client Credential',
          field: 'client_credential',
          width: '15%',
          editComponent: props =>
            <FormControl>
              <Select
                id='client_credential'
                name='client_credential'
                style={{ width: '150px' }}
                defaultValue={props.value}
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem value=''>None</MenuItem>
                {this.state.passwords.map(credential =>
                  <MenuItem key={credential.stanza} value={credential.stanza}> {credential.stanza}</MenuItem>
                )}
              </Select>
            </FormControl>
        },
        {
          title: 'Public Key ID',
          field: 'public_key_id',
          width: '9%',
          validate: rowData => validators.string(rowData.public_key_id)
        },
        {
          title: 'Private Key',
          field: 'private_key',
          width: '36%',
          cellStyle: { wordBreak: 'keep-all' },
          validate: rowData => validators.string(rowData.private_key).isValid,
          render: rowData => <span className='password_field'> {((rowData.private_key === undefined || rowData.private_key === '') ? '' : '[configured]')}</span>,
          editComponent: ({ value, onChange }) => (
            <TextField
              error={(value == null || !validators.string(value).isValid)}
              onChange={e => { onChange(e.target.value) }}
              value={value}
              placeholder='Private Key'
              multiline
              minRows={1}
              maxRax={4}
            />)
        },
        {
          title: 'Passphrase Credential',
          field: 'passphrase_credential',
          width: '15%',
          editComponent: props =>
            <FormControl>
              <Select
                id='passphrase_credential'
                name='passphrase_credential'
                style={{ width: '150px' }}
                defaultValue={props.value}
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem value=''>None</MenuItem>
                {this.state.passwords.map(credential =>
                  <MenuItem key={credential.stanza} value={credential.stanza}> {credential.stanza}</MenuItem>
                )}
              </Select>
            </FormControl>
        },
        { title: 'Default Folder', field: 'default_folder', width: '20%' },
        {
          title: 'Compress Output',
          field: 'compress',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        }
      ],
      ep_sftp: [
        { title: 'Stanza', field: 'stanza', hidden: true },
        // actions = 10%
        {
          title: 'Default',
          field: 'default',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        },
        {
          title: 'Name/Alias',
          field: 'alias',
          width: '14%',
          validate: rowData => validators.string(rowData.alias).isValid
        },
        {
          title: 'Hostname',
          field: 'host',
          width: '35%',
          validate: rowData => validators.string(rowData.host).isValid
        },
        {
          title: 'TCP Port',
          field: 'port',
          width: '10%',
          validate: rowData => (validators.number(rowData.port).isValid || rowData.port == null || rowData.port === '')
        },
        {
          title: 'User Credential',
          field: 'credential',
          width: '15%',
          editComponent: props =>
            <FormControl>
              <Select
                id='credential'
                name='credential'
                style={{ width: '150px' }}
                defaultValue={props.value}
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem value=''>None</MenuItem>
                {this.state.passwords.map(credential =>
                  <MenuItem key={credential.stanza} value={credential.stanza}> {credential.stanza}</MenuItem>
                )}
              </Select>
            </FormControl>
        },
        {
          title: 'Private Key',
          field: 'private_key',
          width: '36%',
          cellStyle: { wordBreak: 'keep-all' },
          render: rowData => <span className='password_field'> {((rowData.private_key === undefined || rowData.private_key === '') ? '' : '[configured]')}</span>,
          validate: rowData =>
            (this.isSplunkCloud && rowData.private_key !== undefined && rowData.private_key !== '' && (rowData.passphrase_credential === '' || rowData.passphrase_credential === undefined))
              ? { isValid: false, helperText: 'Cannot be unencrypted in Splunk Cloud. Select a decryption credential.' }
              : { isValid: true, helperText: '' },
          editComponent: props => (
            <TextField
              error={validators.string(props.value).isValid && (props.rowData.passphrase_credential == null || props.rowData.passphrase_credential === '') && this.isSplunkCloud}
              helperText={props.error && props.helperText}
              onChange={e => { props.onChange(e.target.value) }}
              value={props.value}
              placeholder='Private Key'
              multiline
              minRows={1}
              maxRax={4}
            />)
        },
        {
          title: 'Passphrase Credential',
          field: 'passphrase_credential',
          width: '15%',
          // Force using a passphrase / encrypting the private key in Splunk Cloud
          editComponent: props =>
            <FormControl>
              <Select
                id='passphrase_credential'
                name='passphrase_credential'
                style={{ width: '150px' }}
                defaultValue={props.value}
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem value=''>None</MenuItem>
                {this.state.passwords.map(credential =>
                  <MenuItem key={credential.stanza} value={credential.stanza}> {credential.stanza}</MenuItem>
                )}
              </Select>
            </FormControl>
        },
        { title: 'Default Folder', field: 'default_folder', width: '20%' },
        {
          title: 'Compress Output',
          field: 'compress',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        }
      ],
      ep_smb: [
        { title: 'Stanza', field: 'stanza', hidden: true },
        // actions = 10%
        {
          title: 'Default',
          field: 'default',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        },
        {
          title: 'Name/Alias',
          field: 'alias',
          width: '14%',
          validate: rowData => validators.string(rowData.alias)
        },
        {
          title: 'Hostname',
          field: 'host',
          width: '35%',
          validate: rowData => validators.string(rowData.host)
        },
        {
          title: 'Credential',
          field: 'credential',
          width: '15%',
          editComponent: props =>
            <FormControl>
              <Select
                id='credential'
                name='credential'
                style={{ width: '150px' }}
                defaultValue={props.value}
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem value=''>None</MenuItem>
                {this.state.passwords.map(credential =>
                  <MenuItem key={credential.stanza} value={credential.stanza}> {credential.stanza}</MenuItem>
                )}
              </Select>
            </FormControl>
        },
        {
          title: 'Share Name',
          field: 'share_name',
          width: '15%',
          validate: rowData => validators.string(rowData.share_name).isValid
        },
        { title: 'Default Folder', field: 'default_folder', width: '20%' },
        {
          title: 'Compress Output',
          field: 'compress',
          type: 'boolean',
          width: '5%',
          headerStyle: centerTableHeaderStyles,
          cellStyle: centerTableCellStyles
        }
      ],
      passwords: [
        // actions = 10%
        {
          title: 'Username',
          field: 'username',
          width: '15%',
          validate: rowData => validators.string(rowData.username).isValid,
          editComponent: props => (
            (props.rowData.id && <span> {props.rowData.username}</span>) ||
              <TextField
                value={props.value}
                inputProps={{ placeholder: 'Username' }}
                onChange={e => { props.onChange(e.target.value) }}
              />)
        },
        {
          title: 'Password',
          field: 'password',
          width: '15%',
          validate: rowData => validators.string(rowData.password).isValid,
          render: rowData => <span className='password_field'> {((rowData.password === undefined || rowData.password === '') ? '' : '*'.repeat(8))}</span>,
          editComponent: props => (
            <TextField
              error={(props.value == null || !validators.string(props.value).isValid)}
              type='password'
              value={props.value}
              inputProps={{ placeholder: 'Password' }}
              onChange={e => { props.onChange(e.target.value) }}
            />)
        },
        {
          title: 'Realm/Domain',
          field: 'realm',
          width: '15%',
          editComponent: props => (
            (props.rowData.id && <span> {props.rowData.realm}</span>) ||
              <TextField
                value={props.value}
                inputProps={{ placeholder: 'Realm' }}
                onChange={e => { props.onChange(e.target.value) }}
              />)
        },
        {
          title: 'Owner',
          field: 'owner',
          width: '10%',
          editComponent: props =>
            <FormControl>
              <Select
                id='owner'
                name='owner'
                style={{ width: '150px' }}
                defaultValue={props.value ?? 'nobody'}
                ref={this.credentialOwnerSetting}
              // value= { !props.value ? 'nobody' : props.value }
                onChange={e => props.onChange(e.target.value)}
              >
                <MenuItem key='nobody' value='nobody'>nobody</MenuItem>
                {this.state.users.map(user => (
                  <MenuItem key={user.name} value={user.name}> {user.name}</MenuItem>
                ))}
              </Select>
            </FormControl>
        },
        {
          title: 'Read',
          field: 'read',
          width: '20%',
          render: rowData => <span> {rowData.read.join(', ')}</span>,
          editComponent: props =>
            <FormControl>
              <Select
                id='read'
                name='read'
                style={{ width: '180px' }}
                defaultValue={(Array.isArray(props.value) && props.value) || (props.value && [props.value]) || ['*']}
                ref={this.credentialReadSetting}
                multiple
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem key='*' value='*'>All</MenuItem>
                {this.state.roles.map(role =>
                  <MenuItem key={role.name} value={role.name}> {role.name}</MenuItem>
                )}
              </Select>
            </FormControl>
        },
        {
          title: 'Write',
          field: 'write',
          width: '20%',
          render: rowData => <span> {rowData.write.join(', ')}</span>,
          editComponent: props =>
            <FormControl>
              <Select
                id='write'
                name='write'
                style={{ width: '180px' }}
                defaultValue={(Array.isArray(props.value) && props.value) || (props.value && [props.value]) || ['*']}
                ref={this.credentialWriteSetting}
                multiple
                onChange={e => { props.onChange(e.target.value) }}
              >
                <MenuItem key='*' value='*'>All</MenuItem>
                {this.state.roles.map(role =>
                  <MenuItem key={role.name} value={role.name}> {role.name}</MenuItem>
                )}
              </Select>
            </FormControl>
        }
      ]
    }

    this.refresh_tables()
  }

  // Download the data and push it into the corresponding state entry
  refresh_tables = () => {
    this.setState({ loadingConfig: true })
    const tables = Object.keys(this.columns)
    console.log('Refreshing tables')
    // Promise.all(tables.map( async (table) => {
    Promise.all(tables.map((table) => {
      // console.log(`Refreshing ${table}`)
      const d = this.refresh_table(table, false)
      return d
    }))
      .then((tableData) => {
      // Convert array of single-item dicts to one dict
      // Passwords a 3-item dict
        const newState = { loadingConfig: false }
        tableData?.forEach((tableDict) => {
          if (tableDict != null) {
            for (const [key, value] of Object.entries(tableDict)) {
              newState[key] = value
            }
          }
        })
        // console.log(JSON.stringify(new_state))
        this.setState(newState)
        console.log('Refreshing tables complete')
      })
  }

  // Download data for an individual table and update the state
  refresh_table = (table, setstate = true) => {
    return new Promise((resolve, reject) => {
      this.get_config(table).then((d) => {
        let tableData
        if (table === 'passwords') {
          tableData = d
        } else {
          // Convert the REST response data into a usable row format
          tableData = { [table]: this.rest_to_rows(table, d) }
        }
        if (setstate) {
          this.setState(tableData)
          console.log(`State set for ${table}`)
        }
        resolve(tableData)
      })
    })
  }

  // Convert an object to an HTTP query string (for Splunk configuration POST requests)
  dict_to_querystring = (d) => {
    const queryList = []
    const itemList = Object.entries(d)
    for (const item of itemList) {
      const name = item[0]
      const val = encodeURIComponent(item[1])
      queryList.push(name + '=' + val)
    }
    // console.log('Query list: ' + query_list.toString())
    // Join list with & for query string
    return queryList.join('&')
  }

  // Convert REST API responses to a list of objects that translate to table rows
  rest_to_rows = (configFile, d) => {
    const rows = []
    // Get the names of fields from the columns definition
    const validFields = this.list_table_fields(this.columns[configFile])
    // console.log(`Valid fields for ${configFile}: ${JSON.stringify(valid_fields)}`)
    for (const restEntry of d) {
      const row = restEntry.content
      row.stanza = restEntry.name
      for (const key of Object.keys(row)) {
        // Sanitize the output from the API to only include our defined columns
        if (!validFields.includes(key)) {
          delete row[key]
        } else {
          // Find boolean fields and convert the values from strings
          for (const field of this.columns[configFile]) {
            if (field.field === key && field.type === 'boolean') {
              row[key] = booleanize(row[key])
            }
          }
        }
      }
      rows.push(row)
    }
    return rows
  }

  list_table_fields = (l) => {
    // l = List of dicts passed
    const fields = []

    for (const d of l) {
      fields.push(d.field)
    }
    return fields
  }

  // If 'Default' attribute is set, unset it for all other entries in the configuration
  unset_default_entry = (configFile, newData) => {
    return new Promise((resolve, reject) => {
      // Only do something if the new/updated entry is set to default=true
      if ((newData.default === undefined) ? false : newData.default) {
        console.log('Finding default entry')
        const oldDefaultEntry = this.state[configFile].find(entry => entry.default === true)

        // Make sure a default exists in the first place
        if (oldDefaultEntry !== undefined) {
          if (oldDefaultEntry.stanza !== newData.stanza && oldDefaultEntry.default) {
            const updatedOldEntry = { ...oldDefaultEntry }
            // console.log('old_default_entry: ' + JSON.stringify(old_default_entry))
            // console.log('updated_old_entry: ' + JSON.stringify(updated_old_entry))
            delete updatedOldEntry.tableData
            updatedOldEntry.default = false
            this.update_row_data(configFile, updatedOldEntry, oldDefaultEntry).then(() => resolve())
          }
        }
        // }
      }
      resolve()
    })
  }

  get_missing_form_data = (configFile, newData) => {
    // Check for missing items, e.g. blank values
    const expectedFields = []
    this.columns[configFile].foreach(c => {
      expectedFields.push(c.field)
    })
    console.log(`Fields enumerated for ${configFile}: ${expectedFields.join(', ')}`)
    const missingfields = []
    expectedFields.foreach(f => {
      if (!(f in newData)) {
        missingfields.push(f)
      }
    })
    /* if (missingfields.length > 0) {
      console.log(`Missing fields for ${configFile}: ${missingfields.join(', ')}`)
      // Get the missing field values from the table in case they were set
      missingfields.foreach(missingFieldName => {
        try {
          // dropdown value DOM path
          const v = $(`#${missingFieldName} + input`).val()
          if (v != null) {
            newData[missingFieldName] = v
            console.log(`Found missing field ${missingFieldName} = ${v}`)
          }
        } catch (error) {
          console.error(error)
        }
      })
    } */

    return newData
  }

  get_user_info = () => {
    return new Promise((resolve, reject) => {
      const endpoint = '/servicesNS/-/-/server/info/server-info'
      this.get_endpoint(endpoint).then((d) => {
        resolve(d[0].content)
      })
    })
  }

  get_server_info = () => {
    return new Promise((resolve, reject) => {
      const endpoint = '/servicesNS/-/-/server/info/server-info'
      this.get_endpoint(endpoint).then((d) => {
        resolve(d[0].content)
      })
    })
  }

  get_config_stanza = (configFile, stanza) => {
    return new Promise((resolve, reject) => {
      this.props.splunk.get(`${app}/${configFile}/${stanza}`).then((d) => {
        const clear = JSON.parse(d)
        // resolve(clear)
        resolve(clear.entry[0].content)
      })
    })
  }

  get_config = (configFile) => {
    return new Promise((resolve, reject) => {
      if (configFile === 'passwords') {
        const passwordEndpoint = `/servicesNS/-/${app}/storage/passwords`
        this.get_endpoint(passwordEndpoint).then((passwords) => {
          const roleEndpoint = '/servicesNS/-/-/authorization/roles'
          this.get_endpoint(roleEndpoint).then((roles) => {
            const userEndpoint = '/servicesNS/-/-/authentication/users'
            this.get_endpoint(userEndpoint).then((users) => {
              const pwList = []
              for (const password of passwords) {
                if (password.acl.app === app) {
                  // Build the custom password object to match the row fields in the UI
                  const c = { }
                  c.stanza = password.name
                  c.id = password.id
                  c.username = password.content.username
                  c.password = password.content.encr_password
                  c.realm = password.content.realm
                  c.sharing = password.acl.sharing
                  c.owner = password.acl.owner
                  c.read = password.acl.perms.read
                  c.write = password.acl.perms.write
                  c.links = password.links
                  c.api_entry = password
                  pwList.push(c)
                }
              }
              const passwordState = {
                passwords: pwList,
                users,
                roles
              }
              resolve(passwordState)
            })
          })
        })
      } else {
        const endpoint = `/servicesNS/-/${app}/${app}/${configFile}`
        resolve(this.get_endpoint(endpoint))
      }
    })
  }

  get_endpoint = (endpoint) => {
    return new Promise((resolve, reject) => {
      const params = {
        output_mode: 'json',
        count: '0'
      }
      this.props.splunk.request(endpoint,
        'GET',
        params,
        null,
        null,
        { 'Content-Type': 'application/x-www-form-urlencoded' },
        (err, response) => {
          if (err == null) {
            resolve(response.data.entry)
          } else {
            enqueueSnackbar(`Error querying ${endpoint}:\n ${err.status}: ${err.error}`, notistackOptions('error'))
            reject(err)
          }
        }
      )
    })
  }

  put_config_item = (configFile, items) => {
    // console.log('Config file = ' + configFile)
    return new Promise((resolve, reject) => {
      const itemsCopy = { ...items }
      let restEndpoint
      if (configFile === 'passwords') {
        // console.log('items = ' + JSON.stringify(items_copy))
        restEndpoint = `/servicesNS/-/${app}/storage/passwords`
        // Rename property username to name
        itemsCopy.name = itemsCopy.username
        delete itemsCopy.username
        delete itemsCopy.owner
        delete itemsCopy.stanza
        delete itemsCopy.read
        delete itemsCopy.write
        // console.log(itemsCopy)
      } else if ('stanza' in itemsCopy) {
        restEndpoint = `${app}/${configFile}/${itemsCopy.stanza}`
      } else {
        restEndpoint = `${app}/${configFile}`
      }

      this.props.splunk.request(restEndpoint,
        'POST',
        { output_mode: 'json' },
        null,
        this.dict_to_querystring(itemsCopy),
        { 'Content-Type': 'application/x-www-form-urlencoded' },
        (err, response) => {
          if (err == null) {
            enqueueSnackbar('Record created successfully', notistackOptions('success'))
            resolve(response.data)
          } else {
            enqueueSnackbar(`Error creating record:\n ${err.status}: ${err.error}`, notistackOptions('error'))
            reject(err)
          }
        }
      )
    })
  }

  // Set the state data when adding a configuration item using the table view
  add_row_data = async (configFile, newData) => {
    console.log('New data = ' + JSON.stringify(newData))
    return new Promise((resolve, reject) => {
      if (configFile !== 'passwords') {
        newData.stanza = uuid.v4()
      }
      const dataNew = [...this.state[configFile]]
      // If 'default' is set for this new record, unset it for any other records that might have it
      this.unset_default_entry(configFile, newData).then(() => {
        newData = this.get_missing_form_data(configFile, newData)
        this.put_config_item(configFile, newData).then(d => {
          return new Promise((resolve, reject) => {
            // console.log('[create] newData = ' + JSON.stringify(newData))
            // console.log('d = ' + JSON.stringify(d))
            if (configFile === 'passwords') {
              const remoteCredentialEntry = d.entry[0]
              const c = { }
              // Build the custom password object to match the row fields in the UI
              c.stanza = remoteCredentialEntry.name
              c.id = remoteCredentialEntry.id
              c.username = remoteCredentialEntry.content.username
              c.password = remoteCredentialEntry.content.encr_password
              c.realm = remoteCredentialEntry.content.realm
              c.sharing = remoteCredentialEntry.acl.sharing
              c.app = remoteCredentialEntry.acl.app
              c.links = remoteCredentialEntry.links
              c.api_entry = remoteCredentialEntry
              // Material-UI refuses to pass these values into newData
              c.owner = newData.owner
              c.read = Array.isArray(newData.read) ? newData.read : newData.read.split(',')
              c.write = Array.isArray(newData.write) ? newData.write : newData.write.split(',')

              // Update the ACL to what was supplied
              // Check to see if it is different from default
              if (c.owner !== remoteCredentialEntry.acl.owner ||
                JSON.stringify(c.read) !== JSON.stringify(remoteCredentialEntry.acl.perms.read) ||
                JSON.stringify(c.write) !== JSON.stringify(remoteCredentialEntry.acl.perms.write)) {
                // (username, stanza, owner, read, write, sharing)
                this.update_credential_acl(
                  c.stanza,
                  c.realm,
                  c.owner,
                  c.read,
                  c.write,
                  'global'
                ).then(r => {
                  resolve(c)
                })
              } else {
                resolve(c)
              }
            } else {
              resolve(newData)
            }
          }).then(d => {
            dataNew.push(d)
            console.log('Setting state from add_row_data')
            this.setState({ [configFile]: dataNew })
            // this.refresh_table(configFile)
            resolve()
          })
        })
      })
    })
  }

  // Update the configuration file using the EAI REST endpoint
  update_config_item = (configFile, item) => {
    // console.log('Item = ' + JSON.stringify(item))
    return new Promise((resolve, reject) => {
      if (item?.tableData) {
        delete item.tableData
      }
      let restEndpoint
      if (configFile === 'passwords') {
        restEndpoint = `/servicesNS/-/${app}/storage/passwords/${item.stanza.replace(/(:|%3A)+$/i, '')}`
        // See if the ACL needs updating
        const oldCred = this.state.passwords.find(credential => credential.stanza === item.stanza)
        const newACL = {
          owner: this.credentialOwnerSetting?.current.value,
          read: this.credentialReadSetting?.current.value,
          write: this.credentialWriteSetting?.current.value
        }
        if (oldCred.owner !== newACL.owner ||
          JSON.stringify(oldCred.read) !== JSON.stringify(newACL.read) ||
          JSON.stringify(oldCred.write) !== JSON.stringify(newACL.write)) {
          // Update the ACL
          this.update_credential_acl(
            item.stanza,
            item.realm,
            newACL.owner,
            newACL.read,
            newACL.write,
            'global'
          )
        }
        const itemCopy = { password: item.password }
        // Move the pointer to our new object
        item = itemCopy
      } else {
        restEndpoint = `${app}/${configFile}/${item.stanza}`
      }

      this.props.splunk.request(restEndpoint,
        'POST',
        { output_mode: 'json' },
        null,
        this.dict_to_querystring(item),
        { 'Content-Type': 'application/x-www-form-urlencoded' },
        (err, response) => {
          if (err == null) {
            enqueueSnackbar('Update successful', notistackOptions('success'))
            resolve(response.data)
          } else {
            enqueueSnackbar(`Error updating record:\n ${err.status}: ${err.error}`, notistackOptions('error'))
            reject(err)
          }
        }
      )
    })
  }

  // Update the UI and state
  update_row_data = (configFile, updatedEntry, originalEntry) => {
    return new Promise((resolve, reject) => {
      // Account for values set to blank, which are not submitted automatically
      updatedEntry = this.get_missing_form_data(configFile, updatedEntry)

      // If 'default' is set for this updated record, unset it for any other records that might have it
      this.unset_default_entry(configFile, updatedEntry).then(() => {
        this.update_config_item(configFile, updatedEntry).then(() => {
          // this.refresh_table(configFile)
          console.log('Setting state from update_row_data')
          const dataUpdate = [...this.state[configFile]]
          const index = originalEntry.tableData.id
          dataUpdate[index] = updatedEntry
          this.setState({ [configFile]: dataUpdate })
          resolve()
        })
      })
    })
  }

  delete_config_item = (configFile, stanza) => {
    return new Promise((resolve, reject) => {
      let restEndpoint
      if (configFile === 'passwords') {
        restEndpoint = `/servicesNS/-/${app}/storage/passwords/${stanza.replace(/:+$/, '')}`
      } else {
        restEndpoint = `${app}/${configFile}/${stanza}`
      }

      this.props.splunk.request(restEndpoint,
        'DELETE',
        { output_mode: 'json' },
        null,
        null,
        { 'Content-Type': 'application/x-www-form-urlencoded' },
        (err, response) => {
          if (err == null) {
            enqueueSnackbar('Record deleted successfully', notistackOptions('success'))
            resolve(response.data)
          } else {
            enqueueSnackbar(`Error deleting record:\n ${err.status}: ${err.error}`, notistackOptions('error'))
            reject(err)
          }
        }
      )
    })
  }

  delete_row_data = (configFile, oldData) => {
    return new Promise((resolve, reject) => {
      const dataDelete = [...this.state[configFile]]
      const index = oldData.tableData.id
      dataDelete.splice(index, 1)
      this.delete_config_item(configFile, oldData.stanza).then(() => {
        console.log('Setting state from delete_row_data')
        this.setState({ [configFile]: dataDelete })
        // this.refresh_table(configFile)
        resolve()
      })
    })
  }

  update_credential_acl = (username, realm, owner, read, write, sharing) => {
    return new Promise((resolve, reject) => {
      // read and write must be arrays
      const acl = {
        'perms.read': read,
        'perms.write': write,
        sharing,
        owner
      }
      // console.log('New ACL = ' + JSON.stringify(acl))
      const restEndpoint = `configs/conf-passwords/credential%3A${username}/acl`
      this.props.splunk.request(restEndpoint,
        'POST',
        { output_mode: 'json' },
        null,
        this.dict_to_querystring(acl),
        { 'Content-Type': 'application/x-www-form-urlencoded' },
        (err, response) => {
          if (err == null) {
            enqueueSnackbar('ACL update successful', notistackOptions('success'))
            resolve(response.data)
          } else {
            enqueueSnackbar(`Error updating ACL:\n ${err.status}: ${err.error}`, notistackOptions('error'))
            this.setState({ loadingConfig: false })
            reject(err)
          }
        }
      )
    })
  }

  handleFileAction = (data) => {
    if (!data.payload.targetFile || !data.payload.targetFile.isDir) return
    const newPrefix = `${data.payload.targetFile.id.replace(/\/*$/, '')}/`
    this.show_folder_contents(this.state.currentConfig, this.state.currentConfigAlias, this.state.currentConfigContainer, newPrefix)
  }

  // Set the state data when adding a configuration item using the table view
  show_folder_contents = (configFile, alias, containerName, folder) => {
    return new Promise((resolve, reject) => {
      // Showing folder data
      const oldChain = [...this.state.folderChain]
      const oldFiles = [...this.state.fileList]
      console.log('Old chain = ' + JSON.stringify(oldChain))
      console.log('Old files = ' + JSON.stringify(oldFiles))

      if (containerName === undefined || containerName === null || containerName.length === 0) {
        containerName = '/'
      }

      this.setState({
        loadingFileBrowser: true,
        showFileBrowser: true,
        current_config: configFile,
        current_config_alias: alias,
        current_config_container: containerName
      }, () => { // then
        const url = `${app}_dirlist`
        const params = {
          config: configFile,
          alias
        }

        // Start with the root - /
        let chain = [{
          id: '/',
          name: '/',
          isDir: true
        }]

        // If the query folder is blank, use the default container name in the chain
        // else, use what's in the folder setting only
        console.log('Container Name = ' + containerName)
        console.log('Folder = ' + folder)

        if (folder !== undefined && folder !== null && folder.length > 0) {
          params.folder = folder
          let chainPath = ''
          if (folder.match(/^[0-9]+\/$/)) {
            // Treat the folder like an ID
            chain = []
            folder = folder.replace('/', '')
            console.log('Using folder argument as ID')
            // Is this ID already in the previously used chain? User opted to go backwards
            console.log('Old chain: ' + JSON.stringify(oldChain))
            if (oldChain.length > 0) {
              for (const chainEntry of oldChain) {
                chain.push(chainEntry)
                // Break if the just-added ID is the folder specified
                if (chainEntry.id === folder) {
                  break
                }
              }
              console.log('New chain 1: ' + JSON.stringify(chain))
              if (oldChain.length === chain.length) {
                // We made it through our old chain without finding the selection
                // Must have been selected from the list shown
                // Get the object from the file list and append it to the folder chain
                for (const oldFile of oldFiles) {
                  console.log(folder + ' / ' + oldFile.id)
                  if (oldFile.id === folder) {
                    chain.push(oldFile)
                    break
                  }
                }
                console.log('New chain 2: ' + JSON.stringify(chain))
              }
            }
          } else {
            console.log('Using folder argument as path')
            // Treat the folder argument like a path
            // Strip / from beginning and end
            for (const f of folder.replace(/^\/+|\/+$/, '').replace(/\\+/g, '/').replace(/\/+/g, '/').split('/')) {
              if (f.length > 0) {
                chainPath = chainPath + '/' + f
                chain.push({
                  id: chainPath,
                  name: f,
                  isDir: true
                })
                console.log('f = ' + f)
              }
            }
          }
        } else if ((folder === undefined || folder === null || folder.length === 0) && containerName !== '/') {
          // Append the root file (folder) object - container_name = share, bucket, /, etc.
          chain.push({
            id: containerName, // '/',
            name: containerName,
            isDir: true
          })
        }
        // console.log('Setting chain to: ' + JSON.stringify(chain))

        this.props.splunk.get(url, params)
          .then((d) => {
            const response = JSON.parse(d)
            let fileList
            if ('entry' in response) {
              // Different format of response from Splunk. Get the data from within the object.
              if ('content' in response.entry[0] && Array.isArray(response.entry[0].content)) {
                fileList = JSON.parse(response.entry[0].content[0].payload)
              } else {
                // Error
                const responseData = { }
                // Convert the response to a dict
                for (const e of response.entry) {
                  responseData[e.title] = e.content
                }
                window.alert(`${responseData.status} Error retrieving the file listing: \n${responseData.error}`)
                this.setState({ loadingFileBrowser: false, showFileBrowser: false })
                reject(responseData)
              }
            } else {
              fileList = response
            }
            if (fileList != null) {
              if ('entry' in fileList) {
                // Different format of response from Splunk. Get the data from within the object.
                fileList = JSON.parse(fileList.entry[0].content[0].payload)
              }
              // console.log('File list = ' + JSON.stringify(fileList))
              for (let f = 0; f < fileList.length; f++) {
                if (fileList[f].modDate !== undefined) {
                  if (Number(fileList[f].modDate) !== 0) {
                    // Firefox only works with the ISO string
                    const printedDate = moment.unix(Number(fileList[f].modDate))
                    fileList[f].modDate = printedDate.toISOString()
                  } else {
                    delete fileList[f].modDate
                  }
                }
              }
              this.setState({ fileList }, () => {
                // console.log('Setting state from show_folder_contents (last)')
                this.setState({
                  loadingFileBrowser: false,
                  folderChain: chain
                })
              })
              // console.log(fileList)
              resolve(fileList)
            }
          }, reason => {
            window.alert(`${reason.status} Error retrieving the file listing: \n${reason.responseText}`)
            this.setState({ loadingFileBrowser: false, showFileBrowser: false })
            reject(reason)
          })
      }
      )
      resolve()
    })
  }

  componentDidMount = () => {

  }

  updateParentState = (prop) => {
    this.setState(Object.assign(this.state, prop))
  }

  EPTabContent = (props) => {
    const title = props.title || ''
    const heading = props.heading || ''
    const actionColumns = props.actionColumns || '2'
    const browsable = booleanize(props.browsable || 'false')
    const config = props.config

    return (
      <div className='form form-horizontal form-complex'>
        <h1 className='ep'> {title}</h1>
        {(props.children != null && props.children.length > 0) && (
          <div style={{ width: '700px', paddingBottom: '15px' }}>
            <p> {props.children}</p>
          </div>
        )}

        <div className='panel-element-row'>
          <MaterialTable
            components={{
              Container: props => (
                <div className={'actionicons-' + actionColumns}>
                  <div {...props} />
                </div>
              )
            }}
            title={
              <div className='form form-complex'>
                <h2 className='ep'> {heading}</h2>
              </div>
            }
            icons={tableIcons}
            columns={this.columns[config]}
            data={this.state[config]}
            editable={{
              onRowAdd: newData => this.add_row_data(config, newData),
              onRowUpdate: (newData, oldData) => this.update_row_data(config, newData, oldData),
              onRowDelete: oldData => this.delete_row_data(config, oldData)
            }}
            actions={([browsable && {
              icon: tableIcons.Open,
              tooltip: 'Browse',
              onClick: (event, rowData) => { this.show_folder_contents(config, rowData.alias, rowData.share_name || rowData.default_s3_bucket || rowData.default_container, rowData.default_folder) }
            },
            {
              icon: tableIcons.Refresh,
              tooltip: 'Refresh',
              isFreeAction: true,
              onClick: (event) => this.refresh_tables()
            }])}
            options={tableOptions}
            className={'actionicons-' + actionColumns}
          />
        </div>
      </div>
    )
  }

  render () {
    // const self = this
    console.log('Rendering')
    return (
      <ThemeProvider theme={theme}>
        <div>
          <Suspense fallback={<div>Loading...</div>}>
            {this.state.loadingConfig && <LoadingOverlayAppConfig />}
            {this.state.loadingFileBrowser && <LoadingOverlayFileBrowser />}
          </Suspense>
          <Tabs
            id='tabs_list' className='nav nav-tabs'
            defaultIndex={0} transition={false}
          >
            <TabList className='nav nav-tabs'>
              <Tab className='nav-item'><a href='#' className='toggle-tab'>General</a></Tab>
              <Tab className='nav-item'><a href='#' className='toggle-tab'>Credentials</a></Tab>
              <Tab className='nav-item'><a href='#' className='toggle-tab'>Splunk HEC</a></Tab>
              <Tab className='nav-item'><a href='#' className='toggle-tab'>AWS S3-Compatible</a></Tab>
              <Tab className='nav-item'><a href='#' className='toggle-tab'>Azure Blob</a></Tab>
              <Tab className='nav-item'><a href='#' className='toggle-tab'>Box</a></Tab>
              <Tab className='nav-item'><a href='#' className='toggle-tab'>SFTP</a></Tab>
              <Tab className='nav-item'><a href='#' className='toggle-tab'>SMB</a></Tab>
            </TabList>
            <TabPanel className='tab-pane'>
              <div className='form form-horizontal form-complex'>
                <h1 className='ep'>General Settings</h1>
                <FormControl id='general_form'>
                  <InputLabel id='logging_label'>Logging Level</InputLabel>
                  <Select
                    labelId='logging_label'
                    id='log_level'
                    style={{ width: '150px' }}
                    value={(this.state.ep_general.log_level === undefined) ? '' : this.state.ep_general.log_level}
                    onChange={(event) => {
                      this.update_config_item(
                        'ep_general',
                        {
                          stanza: 'settings',
                          log_level: event.target.value
                        }
                      )
                      console.log('Setting state from General Settings tab')
                      this.setState({ ep_general: { log_level: event.target.value } })
                    }}
                  >
                    <MenuItem value='DEBUG'>Debug</MenuItem>
                    <MenuItem value='INFO'>Info</MenuItem>
                    <MenuItem value='WARNING'>Warning</MenuItem>
                    <MenuItem value='ERROR'>Error</MenuItem>
                    <MenuItem value='CRITICAL'>Critical</MenuItem>
                  </Select>
                </FormControl>
              </div>
            </TabPanel>
            <TabPanel className='tab-pane'>
              <div className='form form-horizontal form-complex'>
                <h1 className='ep'>Manage Credentials</h1>
                <div style={{ width: '700px', paddingBottom: '15px' }}>
                  <p>Use this panel to configure accounts, passwords, and secrets/passphrases to associate with your configured connections and private keys.  </p>
                  <ul>
                    <li>All credentials are stored securely in the Splunk secret store.</li>
                    <li>Users must have the list_storage_passwords capability to read the credentials added to their roles. This will not give them access to read all passwords, only those you explicitly share.</li>
                    <li>Access is secured using native Splunk roles as configured on this dashboard.</li>
                    <li>Credential objects are exported to all apps so they are available to this app's search commands and alert actions. </li>
                    <li>Only the password field is used for storing passphrases (e.g. for private keys), but the username must still be populated with an arbitrary value.</li>
                  </ul>
                </div>
                <div className='panel-element-row'>
                  <MaterialTable
                    components={{
                      Container: props => (
                        <div className='actionicons-2'>
                          <div {...props} />
                        </div>
                      )
                    }}
                    title={
                      <div className='form form-complex'>
                        <h2 className='ep'>Account Management</h2>
                      </div>
                    }
                    icons={tableIcons}
                    columns={this.columns.passwords}
                    data={this.state.passwords}
                    editable={{
                      onRowAdd: newData => this.add_row_data('passwords', newData),
                      onRowUpdate: (newData, oldData) => this.update_row_data('passwords', newData, oldData),
                      onRowDelete: oldData => this.delete_row_data('passwords', oldData)
                    }}
                    options={tableOptions}
                    className='actionicons-2'
                    actions={[
                      {
                        icon: tableIcons.Refresh,
                        tooltip: 'Refresh',
                        isFreeAction: true,
                        onClick: (event) => this.refresh_tables()
                      }]}
                  />
                </div>
              </div>
            </TabPanel>
            <TabPanel className='tab-pane'>
              <this.EPTabContent
                title='Export to Splunk HTTP Event Collector (ephec)'
                heading='Splunk HTTP Event Collector Connections'
                actionColumns='2'
                config='ep_hec'
              >
                <p>Setup connections to Splunk HTTP Event Collector endpoints, including Cribl Stream.</p>
                <p>For Splunk Cloud, SSL will always be enabled and validation forced, per Splunk policy.</p>
              </this.EPTabContent>
            </TabPanel>
            <TabPanel className='tab-pane'>
              <this.EPTabContent
                title='Export to AWS S3 (epawss3)'
                heading='S3-Compatible Connections'
                actionColumns='3'
                browsable='true'
                config='ep_aws_s3'
              >
                <p>Setup connections for AWS S3-compatible object storage repositories. These include, but are not limited to:</p>
                <ul>
                  <li>S3</li>
                  <li>Google Cloud Storage</li>
                  <li>Oracle Cloud Infrastructure Object Storage</li>
                  <li>MinIO</li>
                  <li>Ceph</li>
                </ul>
                <p>For non-Amazon repositories, an endpoint URL must be specified and the region is generally 'us-east-1' (unless the vendor documentation states otherwise).</p>
                <p>To avoid IAM key issuance and rotation, we recommend assigning an IAM role to your Splunk search head EC2 instance(s) and granting AWS permissions to the IAM role. Then, select '[Use ARN]' to authenticate using the ARN credentials from AWS STS.</p>
              </this.EPTabContent>
            </TabPanel>
            <TabPanel className='tab-pane'>
              <this.EPTabContent
                title='Export to Azure Blob (epazureblob)'
                heading='Azure Blob & Data Lake v2 Connections'
                actionColumns='3'
                browsable='true'
                config='ep_azure_blob'
              >
                <p>Setup connections for Azure Blob object storage or Data Lake repositories.  Please note:</p>
                <ul>
                  <li>If Azure AD is selected, the credential's Username must be the application ID and the Realm must be the the Tenant ID.</li>
                  <li>Storage accounts with hierarchical namespace enabled must have the Type set to Data Lake.</li>
                  <li>Browse functionality requires the 'Storage Blob Data Contributor' role assignment on storage accounts, in addition to the 'Storage Queue Data Contributor' role on Data Lake storage accounts.</li>
                </ul>
              </this.EPTabContent>
            </TabPanel>
            <TabPanel className='tab-pane'>
              <this.EPTabContent
                title='Export to Box (epbox)'
                heading='Box Connections'
                actionColumns='3'
                browsable='true'
                config='ep_box'
              >
                <p>Setup connections to Box.com account(s).</p>
                <p>In your <a href='https://app.box.com/developers/console/newapp'>Box Admin Console</a>, create a new Custom App with Server Authentication (with JWT) and create a new key pair to get this information. Then, submit the new app for authorization.</p>
              </this.EPTabContent>
            </TabPanel>
            <TabPanel className='tab-pane'>
              <this.EPTabContent
                title='Export to SFTP (epsftp)'
                heading='SFTP Connections'
                actionColumns='3'
                browsable='true'
                config='ep_sftp'
              >
                <p>Setup connections to SFTP (SSH File Transfer Protocol) endpoints.</p>
                <p>Choose from one of the following. Note that the username will always be retrieved from the referenced 'password' credential.</p>
                <ul>
                  <li>Password authentication; no private key required.</li>
                  <li>Public key authentication with unencrypted private key (not recommended); no password required (specify a password credential to reference the username). Not permitted in Splunk Cloud.</li>
                  <li>Public key authentication with encrypted private key; no password required (specify a password credential to reference the username), passphrase required.</li>
                </ul>
                <p>If a password is present in your credential and a private key is also specified, the private key will be used for authentication.</p>
              </this.EPTabContent>
            </TabPanel>
            <TabPanel className='tab-pane'>
              <this.EPTabContent
                title='Export to SMB (epsmb)'
                heading='SMB Connections'
                actionColumns='3'
                browsable='true'
                config='ep_smb'
              >
                Setup connections to Windows SMB/CIFS file shares.
              </this.EPTabContent>
            </TabPanel>
          </Tabs>
          <Suspense fallback={<div style={{ width: '100%', margin: '25px auto', textAlign: 'center' }}>Loading Script...</div>}>
            {this.state.showFileBrowser && (
              <FileBrowserModal
                id='file_browser'
                instanceId='ep'
                show={this.state.showFileBrowser}
                onHide={() => {
                  console.log('Setting state from FileBrowserModal')
                  this.setState({
                    showFileBrowser: false,
                    fileList: [],
                    folderChain: []
                  })
                }}
                location={`${configDescriptions[this.state.currentConfig]} / ${this.state.currentConfigAlias}`}
                fileList={this.state.fileList}
                folderChain={this.state.folderChain}
                onFileAction={this.handleFileAction}
              />
            )}
          </Suspense>
        </div>
      </ThemeProvider>
    )
  }
}

export default App
