import React, { Suspense } from 'react'
import { Tab, Tabs, TabList, TabPanel } from 'react-tabs'
import { FormControl, Select, InputLabel, MenuItem } from '@material-ui/core'
import MaterialTable from '@material-table/core'
// import { rootPath, username, app } from '@splunk/splunk-utils/config'
// import { ThemeProvider, createTheme /* , makeStyles */ } from '@material-ui/core/styles'
// import Chip from '@splunk/react-ui/Chip'

// UUID for stanza name generation
import uuid from 'react-native-uuid'
import tableStyles from './TableStyles'
import { EPTabContent } from './TabContent'
import { restToRows } from './Helpers'
import { LoadingOverlayAppConfig, LoadingOverlayFileBrowser } from './Overlays'
import {
  getServerInfo, getConfigStanza, getConfig, updateCredentialACL,
  putConfigItem, deleteConfigItem, updateConfigItem
} from './HelpersSplunk'
import { getColumns } from './TableColumns'
import { SetupDocs } from './SetupDocs'
import c from './Constants'
// import moment from 'moment'
// import 'moment-timezone'

// Stylesheets
import 'react-tabs/style/react-tabs.css'

// Lazy load controls for the file browser UI
const { FileBrowserModal, showFolderContents } = React.lazy(() => import('./FileBrowserModal'))

/* Copyright 2023 Deductiv Inc.
#
# Licensed under the Apache License, Version 2.0 (the 'License')
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an 'AS IS' BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Author: J.R. Murray <jr.murray@deductiv.net>
# Version: 2.3.0 (2023-08-11)
*/

// Material-UI v5 migration
// const theme = createTheme()

/* const useStyles = makeStyles((theme) => {
  root: {
    // some CSS that accesses the theme
  }
}) */

class App extends React.Component {
  state = {
    showFileBrowser: false,
    fileList: [], // begin chonky
    folderChain: [], //
    currentFolder: '', //
    currentConfigContainer: '', //
    currentConfig: '', //
    currentConfigAlias: '', // end chonky,
    loadingConfig: true, // FadeIn control for config load wait
    loadingFileBrowser: false, // FadeIn control for chonky file browsing modal,
    isSplunkCloud: false,
    ep_general: {},
    // table lists
    ep_hec: [],
    ep_aws: [],
    ep_box: [],
    ep_sftp: [],
    ep_smb: [],
    passwords: [],
    roles: [],
    users: []
  }

  constructor (props) {
    super(props)

    this.columns = getColumns()
    // Check to see if we are running Splunk Cloud
    getServerInfo().then((serverInfo) => {
      this.isSplunkCloud = (serverInfo.instance_type === 'cloud')
      const instanceType = serverInfo.instance_type != null ? serverInfo.instance_type : 'Splunk Enterprise'
      console.log(`Instance type: ${instanceType}`)
    })
    console.log('User: ', JSON.stringify(this.props.splunk.currentUser()))
  }

  componentDidMount = () => {
    getConfigStanza('ep_general', 'settings')
      .then((d) => {
        this.setState({ ep_general: d })
      })
      .catch(err => console.log(err))

    this.refreshTables()
  }

  refreshColumns = () => {
    getColumns(
      this.state.users,
      this.state.roles,
      this.state.passwords,
      this.state.isSplunkCloud
    )
  }

  // Download the data and push it into the corresponding state entry
  refreshTables = () => {
    this.setState({ loadingConfig: true })
    let newState = { loadingConfig: false }

    const tables = Object.keys(this.columns)
    console.log('Refreshing tables: ' + JSON.stringify(tables))
    // tablesToRefresh = tables.filter()
    // Promise.all(tables.map( async (table) => {
    Promise.all(tables.map((table) => {
      console.log(`Refreshing ${table}`)
      const d = this.refreshTable(table, false)
      return d
    }))
      .then((tableData) => {
        // Convert array of single-item dicts to one dict
        // Passwords a 3-item dict
        tableData?.forEach((tableDict) => {
          if (tableDict != null) {
            for (const [key, value] of Object.entries(tableDict)) {
              newState[key] = value
            }
          }
        })
        const newColumns = getColumns(
          newState.users,
          newState.roles,
          newState.passwords,
          this.state.isSplunkCloud
        )
        newState = { ...newState, columns: newColumns }
        console.log(JSON.stringify(newState))
        this.setState(newState)
        console.log('Refreshing tables complete')
      })
      .catch(err => console.log(err))
  }

  // Download data for an individual table and update the state
  refreshTable = (table, setstate = true) => {
    return new Promise((resolve, reject) => {
      getConfig(table)
        .then((configEntries) => {
          let tableData
          if (table === 'passwords') {
            tableData = configEntries
          } else {
            // Convert the REST response data into a usable row format
            tableData = { [table]: restToRows(table, configEntries, this.columns[table]) }
          }
          if (setstate) {
            this.setState(tableData)
            console.log(`State set for ${table}`)
          }
          resolve(tableData)
        })
        .catch(err => reject(err))
    })
  }

  // If 'Default' attribute is set, unset it for all other entries in the configuration
  unsetDefaultEntry = (configFile, newData) => {
    return new Promise((resolve, reject) => {
      // Only do something if the new/updated entry is set to default=true
      if ((newData.default === undefined) ? false : newData.default) {
        console.log('Finding default entry')
        const oldDefaultEntry = this.state[configFile].find(entry => entry.default === true)

        // Make sure a default exists in the first place
        if (oldDefaultEntry !== undefined) {
          if (oldDefaultEntry.stanza !== newData.stanza && oldDefaultEntry.default) {
            const updatedOldEntry = { ...oldDefaultEntry }
            // console.log('old_default_entry: ' + JSON.stringify(old_default_entry))
            // console.log('updated_old_entry: ' + JSON.stringify(updated_old_entry))
            delete updatedOldEntry.tableData
            updatedOldEntry.default = false
            this.updateRowData(configFile, updatedOldEntry, oldDefaultEntry)
              .then(() => resolve())
              .catch(err => reject(err))
          }
        }
        // }
      }
      resolve()
    })
  }

  getMissingFormData = (configFile, newData) => {
    // Check for missing items, e.g. blank values
    const expectedFields = []
    this.columns[configFile].forEach(c => {
      expectedFields.push(c.field)
    })
    console.log(`Fields enumerated for ${configFile}: ${expectedFields.join(', ')}`)
    const missingFields = []
    expectedFields.forEach(f => {
      if (!(f in newData)) {
        missingFields.push(f)
      }
    })
    if (missingFields.length > 0) {
      console.log(`Missing fields for ${configFile}: ${missingFields.join(', ')}`)
      // Get the missing field values from the table in case they were set
      missingFields.forEach(missingFieldName => {
        try {
          // dropdown value DOM path
          const v = this.props.splunk_components.$(`#${missingFieldName} + input`).val()
          if (v != null) {
            newData[missingFieldName] = v
            console.log(`Found missing field ${missingFieldName} = ${v}`)
          }
        } catch (error) {
          console.error(error)
        }
      })
    }

    return newData
  }

  // Set the state data when adding a configuration item using the table view
  addRowData = async (configFile, newData) => {
    console.log('New data = ' + JSON.stringify(newData))
    return new Promise((resolve, reject) => {
      if (configFile !== 'passwords') {
        newData.stanza = uuid.v4()
      }
      const dataNew = [...this.state[configFile]]
      // If 'default' is set for this new record, unset it for any other records that might have it
      this.unsetDefaultEntry(configFile, newData)
        .then(() => {
          newData = this.getMissingFormData(configFile, newData)
          putConfigItem(configFile, newData)
            .then(d => {
              return new Promise((resolve, reject) => {
                // console.log('[create] newData = ' + JSON.stringify(newData))
                // console.log('d = ' + JSON.stringify(d))
                if (configFile === 'passwords') {
                  const remoteCredentialEntry = d.entry[0]
                  const c = { }
                  // Build the custom password object to match the row fields in the UI
                  c.stanza = remoteCredentialEntry.name
                  c.id = remoteCredentialEntry.id
                  c.username = remoteCredentialEntry.content.username
                  c.password = remoteCredentialEntry.content.encr_password
                  c.realm = remoteCredentialEntry.content.realm
                  c.sharing = remoteCredentialEntry.acl.sharing
                  c.app = remoteCredentialEntry.acl.app
                  c.links = remoteCredentialEntry.links
                  c.api_entry = remoteCredentialEntry
                  // Material-UI refuses to pass these values into newData
                  c.owner = newData.owner
                  c.read = Array.isArray(newData.read) ? newData.read : newData.read.split(',')
                  c.write = Array.isArray(newData.write) ? newData.write : newData.write.split(',')

                  // Update the ACL to what was supplied
                  // Check to see if it is different from default
                  if (c.owner !== remoteCredentialEntry.acl.owner ||
                    JSON.stringify(c.read) !== JSON.stringify(remoteCredentialEntry.acl.perms.read) ||
                    JSON.stringify(c.write) !== JSON.stringify(remoteCredentialEntry.acl.perms.write)) {
                    // (username, stanza, owner, read, write, sharing)
                    updateCredentialACL(
                      c.stanza,
                      c.realm,
                      c.owner,
                      c.read,
                      c.write,
                      'global'
                    )
                      .then(r => {
                        resolve(c)
                      })
                      .catch(err => {
                        console.log('Setting state from addRowData (updateCredentialACL error)', err)
                        this.setState({ loadingConfig: false })
                        reject(err)
                      })
                  } else {
                    resolve(c)
                  }
                } else {
                  resolve(newData)
                }
              }).then(d => {
                dataNew.push(d)
                console.log('Setting state from addRowData')
                this.setState({ [configFile]: dataNew })
                // this.refreshTable(configFile)
                resolve(d)
              })
            })
            .catch(err => reject(err))
        })
        .catch(err => reject(err))
    })
  }

  // Update the UI and state
  updateRowData = (configFile, updatedEntry, originalEntry) => {
    return new Promise((resolve, reject) => {
      // Account for values set to blank, which are not submitted automatically
      console.log(JSON.stringify(updatedEntry))
      updatedEntry = this.getMissingFormData(configFile, updatedEntry)
      const stateConfigCopy = [...this.state[configFile]]
      const index = originalEntry.tableData.index
      // const index = stateConfigCopy.findIndex((entry) => entry?.stanza === updatedEntry?.stanza)

      // If 'default' is set for this updated record, unset it for any other records that might have it
      this.unsetDefaultEntry(configFile, updatedEntry)
        .then(() => {
          updateConfigItem(configFile, updatedEntry)
            .then(() => {
              // Also set the ACL if we updated the credential and the ACL changed
              if (configFile === 'passwords') {
                // Fields are not populating. Get them manually.
                try {
                  // Sanitize input
                  originalEntry.read = originalEntry.read.filter((role) => role !== '')
                  originalEntry.write = originalEntry.write.filter((role) => role !== '')
                  updatedEntry.read = updatedEntry.read.filter((role) => role !== '')
                  updatedEntry.write = updatedEntry.write.filter((role) => role !== '')

                  // Compare ACLs and update API if changed
                  if (originalEntry.owner !== updatedEntry.owner ||
                      originalEntry.read !== updatedEntry.read ||
                      originalEntry.write !== updatedEntry.write) {
                    console.log('Updating ACL')
                    this.update_credential_acl(
                      updatedEntry.stanza,
                      updatedEntry.realm,
                      updatedEntry.owner,
                      updatedEntry.read,
                      updatedEntry.write,
                      'global'
                    )
                  }
                } catch (err) {
                  console.log(err)
                  reject(err)
                }
              }

              // this.refreshTable(configFile)
              stateConfigCopy[index] = updatedEntry
              this.setState({ [configFile]: stateConfigCopy })
              resolve(stateConfigCopy)
            })
            .catch(err => reject(err))
        })
        .catch(err => reject(err))
    })
  }

  deleteRowData = (configFile, oldData) => {
    return new Promise((resolve, reject) => {
      const dataDelete = [...this.state[configFile]]
      const index = dataDelete.findIndex((entry) => entry?.stanza === oldData?.stanza || entry?.id === oldData?.id)
      dataDelete.splice(index, 1)
      deleteConfigItem(configFile, oldData.stanza)
        .then(() => {
          console.log('Setting state from deleteRowData')
          this.setState({ [configFile]: dataDelete })
          // this.refreshTable(configFile)
          resolve()
        })
        .catch(err => reject(err))
    })
  }

  handleFileAction = (data) => {
    if (!data.payload.targetFile || !data.payload.targetFile.isDir) return
    const newPrefix = `${data.payload.targetFile.id.replace(/\/*$/, '')}/`
    showFolderContents(
      this.state.currentConfig,
      this.state.currentConfigAlias,
      this.state.currentConfigContainer,
      newPrefix
    )
  }

  render () {
    // const self = this
    console.log('Rendering')
    this.refreshColumns()

    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          {this.state?.loadingConfig && <LoadingOverlayAppConfig />}
          {this.state?.loadingFileBrowser && <LoadingOverlayFileBrowser />}
        </Suspense>
        <Tabs
          id='tabs_list' className='nav nav-tabs'
          defaultIndex={0}
        >
          <TabList className='nav nav-tabs'>
            <Tab className='nav-item' key='tab_general'><a href='#' className='toggle-tab'>General</a></Tab>
            <Tab className='nav-item' key='tab_credentials'><a href='#' className='toggle-tab'>Credentials</a></Tab>
            <Tab className='nav-item' key='tab_hec'><a href='#' className='toggle-tab'>Splunk HEC</a></Tab>
            <Tab className='nav-item' key='tab_s3'><a href='#' className='toggle-tab'>AWS S3-Compatible</a></Tab>
            <Tab className='nav-item' key='tab_blob'><a href='#' className='toggle-tab'>Azure Blob</a></Tab>
            <Tab className='nav-item' key='tab_box'><a href='#' className='toggle-tab'>Box</a></Tab>
            <Tab className='nav-item' key='tab_sftp'><a href='#' className='toggle-tab'>SFTP</a></Tab>
            <Tab className='nav-item' key='tab_smb'><a href='#' className='toggle-tab'>SMB</a></Tab>
          </TabList>

          <TabPanel className='tab-pane'>
            <div className='form form-horizontal form-complex'>
              <h1 className='ep'>General Settings</h1>
              <FormControl id='general_form'>
                <InputLabel id='logging_label'>Logging Level</InputLabel>
                <Select
                  labelId='logging_label'
                  id='log_level'
                  style={{ width: '150px' }}
                  value={(this.state?.ep_general.log_level === undefined) ? '' : this.state?.ep_general.log_level}
                  onChange={(event) => {
                    updateConfigItem(
                      'ep_general',
                      {
                        stanza: 'settings',
                        log_level: event.target.value
                      }
                    )
                    console.log('Setting state from General Settings tab')
                    this.setState({ ep_general: { log_level: event.target.value } })
                  }}
                >
                  <MenuItem key='debug' value='DEBUG'>Debug</MenuItem>
                  <MenuItem key='info' value='INFO'>Info</MenuItem>
                  <MenuItem key='warn' value='WARNING'>Warning</MenuItem>
                  <MenuItem key='error' value='ERROR'>Error</MenuItem>
                  <MenuItem key='crit' value='CRITICAL'>Critical</MenuItem>
                </Select>
              </FormControl>
            </div>
          </TabPanel>

          <TabPanel className='tab-pane'>
            <div className='form form-horizontal form-complex'>
              <SetupDocs config='credentials' section='tabDocs' />
              <div className='panel-element-row'>
                <MaterialTable
                  tableRef={this.tableRef}
                  components={{
                    Container: props => (
                      <div className='actionicons-2'>
                        <div {...props} />
                      </div>
                    )
                  }}
                  title={<SetupDocs config='credentials' section='tableTitle' />}
                  icons={tableStyles.icons}
                  columns={this.columns.passwords}
                  data={this.state.passwords}
                  editable={{
                    onRowAdd: newData => this.addRowData('passwords', newData),
                    onRowUpdate: (newData, oldData) => this.updateRowData('passwords', newData, oldData),
                    onRowDelete: oldData => this.deleteRowData('passwords', oldData)
                  }}
                  options={tableStyles.options}
                  className='actionicons-2'
                  actions={[
                    {
                      icon: tableStyles.icons.Refresh,
                      tooltip: 'Refresh',
                      isFreeAction: true,
                      onClick: (event) => this.refreshTables()
                    }]}
                />
              </div>
            </div>
          </TabPanel>

          <TabPanel className='tab-pane'>
            <EPTabContent
              title='Export to Splunk HTTP Event Collector (ephec)'
              heading='Splunk HTTP Event Collector Connections'
              config='ep_hec'
              columns={this.columns.ep_hec}
              handleRowUpdate={this.updateRowData}
              handleRowAdd={this.addRowData}
              handleRowDelete={this.deleteRowData}
            >
              <SetupDocs config='ep_hec' section='tabDocs' />
            </EPTabContent>
          </TabPanel>
          <TabPanel className='tab-pane'>
            <EPTabContent
              title='Export to AWS S3 (epawss3)'
              heading='S3-Compatible Connections'
              browsable
              config='ep_aws_s3'
              columns={this.columns.ep_aws_s3}
              handleRowUpdate={this.updateRowData}
              handleRowAdd={this.addRowData}
              handleRowDelete={this.deleteRowData}
            >
              <SetupDocs config='ep_aws_s3' section='tabDocs' />
            </EPTabContent>
          </TabPanel>
          <TabPanel className='tab-pane'>
            <EPTabContent
              title='Export to Azure Blob (epazureblob)'
              heading='Azure Blob & Data Lake v2 Connections'
              browsable
              config='ep_azure_blob'
              columns={this.columns.ep_azure_blob}
              handleRowUpdate={this.updateRowData}
              handleRowAdd={this.addRowData}
              handleRowDelete={this.deleteRowData}
            >
              <SetupDocs config='ep_azure_blob' section='tabDocs' />
            </EPTabContent>
          </TabPanel>
          <TabPanel className='tab-pane'>
            <EPTabContent
              title='Export to Box (epbox)'
              heading='Box Connections'
              browsable
              config='ep_box'
              columns={this.columns.ep_box}
              handleRowUpdate={this.updateRowData}
              handleRowAdd={this.addRowData}
              handleRowDelete={this.deleteRowData}
            >
              <SetupDocs config='ep_box' section='tabDocs' />
            </EPTabContent>
          </TabPanel>
          <TabPanel className='tab-pane'>
            <EPTabContent
              title='Export to SFTP (epsftp)'
              heading='SFTP Connections'
              browsable
              config='ep_sftp'
              columns={this.columns.ep_sftp}
              handleRowUpdate={this.updateRowData}
              handleRowAdd={this.addRowData}
              handleRowDelete={this.deleteRowData}
            >
              <SetupDocs config='ep_sftp' section='tabDocs' />
            </EPTabContent>
          </TabPanel>
          <TabPanel className='tab-pane'>
            <EPTabContent
              title='Export to SMB (epsmb)'
              heading='SMB Connections'
              browsable
              config='ep_smb'
              columns={this.columns.ep_smb}
              handleRowUpdate={this.updateRowData}
              handleRowAdd={this.addRowData}
              handleRowDelete={this.deleteRowData}
            >
              <SetupDocs config='ep_smb' section='tabDocs' />
            </EPTabContent>
          </TabPanel>
        </Tabs>
        <Suspense fallback={<div style={{ width: '100%', margin: '25px auto', textAlign: 'center' }}>Loading Script...</div>}>
          {this.state?.showFileBrowser && (
            <FileBrowserModal
              id='file_browser'
              instanceId='ep'
              show={this.state?.showFileBrowser}
              onHide={() => {
                console.log('Setting state from FileBrowserModal')
                this.setState({
                  showFileBrowser: false,
                  fileList: [],
                  folderChain: []
                })
              }}
              location={`${c.configDescriptions[this.state.currentConfig]} / ${this.state.currentConfigAlias}`}
              fileList={this.state.fileList}
              folderChain={this.state.folderChain}
              onFileAction={this.handleFileAction}
            />
          )}
        </Suspense>
      </div>
    )
  }
}

export default App
